'''
This example illustrates a simple example of fitting a linear regression model with scipy.optimize.
The data is generated by adding uniform noise to a y=x expression.
Plotting flags are provided for convenience
'''
import numpy as np
from scipy import optimize
import matplotlib.pyplot as plt

def safe_print(*args):
    try: 
        print(*args)
    except:
        pass

#%%
np.random.seed(0)

# Parameters for randomly generated data
noise_radius = 0.1
num_points = 100

# Plotting flags
plot_data = True # Generate plot of training data
plot_best_fit = False # Generate plot of best fit line with training data
plot_abs_deviation = False # Generate plot of deviation from y=x
# Parameters for training data
train_min_x = 0
train_max_x = 100

# Parameters for testing data
num_test = 1000
test_min_x = -100
test_max_x = 1000

# Generate data according to y=x, with uniform noise applied to y (+/- `noise_radius`)
x = np.linspace(train_min_x, train_max_x, num_points)
y = x + (2*noise_radius) * np.random.random_sample(num_points) - noise_radius

#%%
if plot_data:
    fig, ax = plt.subplots(1,1)
    ax.scatter(x,y)
    ax.set_xlabel('X')
    ax.set_ylabel("Y")
    ax.set_title("y = x + noise")
    fig.tight_layout()
    fig.savefig('linear_noise.png')

#%%
weights = np.ones(2) # [a, b]
# Construct a model from the expression: a*x + b
def model(x, weights):  
    return weights[0] * x + weights[1]

# Use the Root Mean Squared Error (RMSE) as the function to minimize
def loss_function(weights):
    return np.sqrt(np.mean((y - model(x, weights))**2))

#%%
results = optimize.minimize(loss_function, weights)
weights = results['x']
loss = results['fun']

safe_print("Weights:\t", weights)
safe_print(f"Final Training Error:\t{loss:.6f}")
safe_print(f"RMSE of Noise:\t\t{np.sqrt(np.mean((y-x)**2)):.6f}")

#%%
### Uncomment to visualize the above data + best fit line
if plot_best_fit:
    fig, ax = plt.subplots(1,1)
    ax.scatter(x,y)
    ax.plot(x, model(x,weights), 'r', label='Best Fit Line')
    ax.set_xlabel('X')
    ax.set_ylabel("Y")
    ax.set_title("y = x + noise")
    ax.legend()
    fig.tight_layout()
    fig.savefig('linear_best_fit_line.png')

#%%
test_x = (test_max_x - test_min_x) * np.random.random_sample(num_test) + test_min_x
test_y = test_x + (2*noise_radius) * np.random.random_sample(num_test) - noise_radius
test_error = np.sqrt(np.mean((test_y-model(test_x,weights))**2))
safe_print(f'Final Testing Error:\t{test_error:.6f}')

if plot_abs_deviation:
    fig, ax = plt.subplots(1,1)
    ax.scatter(test_x, test_y-model(test_x,weights), label='prediction')
    ax.scatter(test_x, test_y-test_x, label='noise')
    ax.set_ylabel("Deviation from y=x")
    ax.set_xlabel("Value of X")
    ax.legend()
    fig.savefig('deviation_from_linear.png')